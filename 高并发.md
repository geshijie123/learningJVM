# java高并发程序设计
## 第一章 走入并行世界
#### 1.1.1 忘掉那该死的并行
并行计算只能在图像处理和服务端编程俩个领域使用，其他地方毫无建树。
#### 1.1.2 可怕的现实，摩尔定律的失效
戈登丶摩尔 集成电路上可容纳的电晶体（晶体管）数目，约24个月便会增加一倍。
这个定律在cpu的计算性能上可能已经失效，虽然inter研制出了4Ghz芯片，但是最近10年的发展中，cpu主频的提升已经明显遇到一些暂时不可逾越的瓶颈。
#### 1.1.3 柳暗花明：不断地前进
但是主频虽然没有太大图片，但是核心数量却增加许多，双核四核八核16核等等，另一方面，摩尔定律还是有效的。
#### 1.1.4 光明或黑暗
多核的出现，只是硬件开发人员吧摩尔定律退给了软件开发者。这对软甲开发来说挺黑暗的。
#### 1.2 你必须知道的几个概念
#### 1.2.1同步（Synchronous）和异步（Asynchronous）
#### 1.2.2并发（Concurrency）和并行（Parallelism）
相同的：
- 都是可以表示俩个或者多个任务一起执行
不同：
- 并发侧重于多个任务交替执行，
- 并行是真正意义上的“同时执行”
并发：
>    ————> ---------->——————>--------->——————>

并行：
>    —————————————>

>    -------------------------->

#### 1.2.3 临界点
临界区用来表示一种公共资源或者共享数据，可以被多个线程使用。但是每一次，只能有一个线程使用它，一旦临界区资源被占用，其它线程想要使用这个资源就必须等待
#### 1.2.4 阻塞（Blocking）和非阻塞（Non-Blocking）
阻塞和非阻塞通常用来形容多线程间的相互影响。
比如一个线程占用了临界区资源，那么其他所有需要这个资源的线程就必须在这个临界区中等待，等待会导致线程挂起，这种情况就是阻塞。
非阻塞的意思与之相反，
#### 1.2.5 死锁（Deadlock）饥饿（Starvation）和活锁（Livelock）
他们都是属于多线程的活跃性问题
- 死锁：多个线程互相占用对方资源，都不主动释放自己的资源，线程进行不下去。
- 饥饿：指一个或多个线程，因为种种原因无法获得所需要的资源，呆滞一直无法执行。
- 活锁：指俩个0智商的线程，同时需要获取某个资源，都秉承着“谦让”的原则，主动将资源释放给对方使用，导致资源不断的被踢皮球，最终没有一个线程职场正常执行。
### 1.3 并发级别
由于临界区的存在，多线程之间的并发必须受到控制。根据控制并发的策略，我们可以吧并发的级别分为阻塞，无饥饿，无障碍，无锁，无等待几种。

    

