#  深入了解JVM
## 第一章 走进jvm
`jdk 包括 java语言，工具及工具API， JRE`
## 第二章 java内存区域与内存溢出异常
### 2.1运行时数据区域
java虚拟机在执行java程序的过程中会把他所管理的内存划分为若干个不同的数据区域。
![Java虚拟机运行时数据区](https://pic4.zhimg.com/v2-2d12cf4d44699ee760ff6874604497a3_r.jpg)
#### 2.1.1 程序计数器
JVM中的程序计数器是一块很小的内存区域，但是这块内存区域挺有意思的。主要特性有3个：
1. 存储内容：对于java普通方法（即没用native关键字修饰的方法），存储的是执行过程中当前指令的地址，而对于native方法，这里是空的（undefined），为啥呢？因为调用本地方法的时候可能已经超出了JVM虚拟机的内存地址了。
2. 线程私有的：为什么程序计数器是线程私有的？根据存储内容也好理解，假如是线程共享的，那多个线程执行的时候，都不知道自己当前线程执行的地址是哪个了，有的线程快，有的线程慢，快的执行完就进入下一步，等慢的线程执行完回来发现自己的地址都变了，岂不乱套？
3. 是JVM中唯一不会报内存溢出（OutOfMemoryError）的区域。
#### 2.1.2 java虚拟机栈
关于虚拟机栈内存溢出有2种情况：
1. 线程请求的栈深度 超过了虚拟机允许的深度，会抛出StackOverflowError，所以当我们在代码中看到这个异常时，就应该想到可能是虚拟机栈出了问题。
2. 如果虚拟机栈可以动态扩展（当前大部分JVM都可以动态扩展，不过JVM也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时，会抛出OutOfMemoryError异常。
#### 2.1.3 本地方法区
这块知识点比较简单，本地方法栈和虚拟机栈的功能类似，只不过是为JVM调用native方法时服务的，而且JVM对本地方法使用的语言（比如Java调用C语言实现的功能，就需要定义native方法来实现）、使用方式和数据结构都没有强制规定，因此不同的虚拟机可以自由实现。而且HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一。与虚拟机栈类似，本地方法栈也会抛出StackOverflowError和OutOfMemoryError。
#### 2.1.4 java堆
Java堆区是JVM内存中最胖的一块区域，因为这里存储的都是对象的实例和数组对象。这块区域是线程共享的，在JVM启动时就会创建，想想如果这么大的空间是线程私有的，那内存不得爆掉吗？按照java虚拟机规范，堆区的内容可以物理上不连续，只要逻辑上连续即可，在实现时可以是固定大小的，也可以是可扩展的，而且通常都是可扩展的，我们常用的内存参数-Xms和-Xmx就是用来调节堆大小的。java堆区按生命周期不同，分为新生代和老年代。新生代又可以细分为Eden和Survivor区，而Survivor又可以细分为Survivor1和Survivor2，这两者通常只使用其中一块，另一块用来GC时保留存活的对象。大部分的new出来的对象都是存放在Eden区，如果是大对象，比如一个很大的数组或者List对象，可以通过JVM参数-XX:PretenureSizeThreshold将超过指定大小的对象直接存入到老年代，需要注意的是，写程序时应该尽量避免朝生夕死的大对象进入老年代，因为相比年轻代的GC，老年代GC的成本更大。Eden和Survivor的默认大小比值的8:1:1，新生代默认的GC算法是复制算法。老年代的默认GC算法是标记整理法。

![](https://pic3.zhimg.com/v2-730e4db82c217037bebfe726602f9486_b.jpg)
### 2.2 HotSpot虚拟机对象探秘
#### 2.2.1 对象的创建
1. 虚拟机在遇到一条new指令时，首先会检查这个指令的参数是否能在常量池中定位到一个类的符号引用,并且检查该类是否已加载。如果没有加载，还要先执行相应的类加载过程
2. 内存分配方式有两种，选择哪种方式由Java堆是否规整决定，若规整，则采用“指针碰撞”方式，若不规整，则采用“空闲列表方式”；而是否规整又由所采用的垃圾回收机制决定
3. 解决并发环境下的分配内存有两种方式:  对分配内存空间的动作进行同步处理  把内存分配的动作按照线程划分在不同的空间中进行，即每个线程在堆中预先分配一小块内存（TLAB）
4. 内存分配完成后还要将分配的内存空间都初始化为零值，从而保证对象的实例字段在Java代码中可以不赋初始值就直接使用
5. 初始化后还要给对象进行相关各设置，诸如哈希码、GC分代年龄信息等6.上述工作结束后，从虚拟机视角来看，一个新的对象已经产生了；但从Java程序的角度来看，对象的创建才刚刚开始————进行Java代码的初始化操作
#### 2.2.2 对象的内存布局
1. 对象在内存中存储的布局可以分为三块区域：对象头、实例数据、对齐填充
2. 对象头一搬包含两部分内容：对象的运行时数据和类型指针。如果对象是数组，则还有一个部分来记录数组的长度
3. 运行时数据指哈希码、GC分代年龄等信息，被设计成一个非固定的数据结构以便在极小的空间存储尽量多的信息，会根据对象的状态复用自己的存储空间
4. 类型指针是对象指向他的类元数据的指针，虚拟机通过这个指针确定对象是哪个类的实例
5. 实例数据是对象真正存储的有效信息，即程序中的字段内容
6. 实例数据默认的分配策略是按顺序，相同宽度的字段总是分配在一起
7. 对齐填充不是必然的，仅仅起着占位符的作用
8. 对象的大小必须是8字节的整数倍，对象头部分正好是8字节的倍数
#### 2.2.3 对象的访问定位
1. Java程序通过栈上的reference数据来操作堆上的具体对象
2. 对象的访问形式取决于虚拟机，目前主流的有两种方式：使用句柄  和  直接指针
3. 使用句柄是间接访问，优点是reference中存储的是稳定的句柄地址，对象移动时只会改变句柄中的实例数据指针
4. 使用直接指针是直接访问，优点就是速度快
### 2.3 OutOfMemoryError异常
#### 2.3.1 java栈溢出
Java堆用于存储对象实例，只要不断的创建对象，且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量达到最大堆的容量限制之后就会产生内存溢出的异常
#### 2.3.2 虚拟机和本地方法栈的溢出
1. HotSpot虚拟机中并不区分虚拟机栈和本地方法栈
2. 关于虚拟机栈和本地方法栈，Java虚拟机规范中描述了量中异常：
- 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常
- 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常
3. 在单个线程下，无论是由于栈太小还是虚拟机栈容量太小，当内存无法分配时，虚拟机抛出的都是StackOverflowError异常
#### 2.3.3 方法区和运行时常量池溢出
1. 在JDK 1.6中 intern() 方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用
2. 在JDK 1.7中 intern() 方法不会再复制实例，只是在常量池中记录首次出现的实例引用
3. StringBuilder 创建的字符串实例在Java堆上
## 第三章 垃圾收集器与内存分配策略
### 3.1 对象已死吗？
#### 3.1.1 引用计数法
主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是他很难解决对象之间互相引用的问题。
#### 3.1.2 可达性分析算法
1. 主流的商用程序语言的主流实现中都是用可达性分析来判断对象是否存活的
2. 从一个起始对象GC Roots开始向下搜索，搜索所走过的路径称为引用链，档一个对象到GC Roots没有任何引用链时，即从GC Roots到这个对象不可达，则证明此对象是不可用的
3. 在Java语言中，可作为GC Roots的对象包括一下四种：
 - 虚拟机栈（栈帧中的本地变量表）中引用的对象
 - 方法区中类静态属性引用的对象
 - 方法区中常亮引用的对象
 - 本地方法栈中JNI(即一般说的Native方法)引用的对象
#### 3.1.3 再谈引用
Java的引用可以分为强引用、软引用、弱引用、虚引用：
- 强引用：是指在程序代码中直接存在的引用，譬如引用new操作符创建的对象。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象
- 软引用：还有用但是并非必需的引用，早系统将要发生内存溢出异常之前会把这些对象列进回收范围中进行二次回收，若还是没有足够的内存，才会抛出内存溢出异常
- 弱引用：非必需的对象，只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论内存是否够用都将回收这些对象
- 虚引用：一个对象是否有虚引用的存在完全不会对他的生存时间构成影响，也无法通过虚引用来取得一个对象实例
#### 3.1.4 生存还是死亡
1. 要真正宣告一个对象死亡，需要两个标记过程：
- 若对象在进行可达性分析后发现没有与GC Roots相连接的引用链，会被第一次标记并筛选。筛选的条件是此对象是否有必要执行finalize()方法
- finalize()方法是对象逃脱死亡的最后一次机会，稍后GC会对对象进行第二次标记
2. 当对象没有覆盖finalize()方法或者finalize()方法已经由虚拟机调用过，都视为finalize()没有必要执行
#### 3.1.5 回收方法区
1. 永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类
2. 类需要同时满足一下三个条件才能算是“无用的类”：
- 该类所有的实例都已经被回收，即Java堆中不再有该类的实例
- 加载该类的ClassLoader已经被回收
- 该类对应的java.lang.Class对象没有在任何地方被调用，无法在任何地方通过反射访问该类的方法
### 3.2 垃圾收集算法
#### 3.2.1 标记-清除算法
1. 算法分为两个阶段：标记和清除  
- 标记：标记所有需要回收的对象  
- 清除：统一回收所有被标记的对象  
2. 优点:简单，是后面其他算法的基础
3. 缺点：标记和清除的效率很低；标记清除之后会产生大量不连续的内存碎片，空间碎片太多会导致以后遇到大对象的时候无法找到足够的内存
#### 3.2.2 复制算法
1. 思路：将可用内存按容量分为两个块，每次只用其中之一。当这一块内存用完之后，将还存活的对象复制到另一边去，然后清除所有已经使用过的部分
2. 优点：实现简单，运行高效
3. 缺点：代价是将内存缩小了一部分，而且可能会需要额外的担保空间
#### 3.2.3 标记-整理算法
1.思路：标记过程和标记-清除一样，但是后续步骤不是直接对可回收对象进行清理，而是将所有活着的对象向一端移动，然后直接清理掉端边界以外的内存
#### 3.2.4 分代收集算法
1.当前商用虚拟机都采用了这种算法，根据对象的存活周期将内存划分为几块，一般是把Java堆分为新生代和老生代，根据各个年代采用适当的收集算法
2.新生代一般【采用复制算法】，老生代一搬采用 【标记-清理】 或者【标记-整理】 进行回收
### 3.3 HotSpot的算法实现
#### 3.3.1 枚举根节点 
1. 目前主流的Java虚拟机使用的都是准确式GC，当执行系统停顿下来后并不需要一个不漏的检查完所有执行上下文和全局的引用变量，虚拟机应当有办法直接得知哪些地方存着对象的引用
2. HotSpot使用一组称为OopMap的数据结构来记录哪些地方存着对象的引用、
3. 在类加载过程中，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中会在特定的位置记录下栈和寄存器中哪些位置是引用
#### 3.3.2 安全点
1. 只是在特定位置记录了这些信息，这些位置称为安全点
2. 程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停
3. 给多线程记录安全点时有两种方案：抢先式中断 和 主动式中断
4. 主动式中断的思想是当GC需要中断线程时不直接对线程进行操作，仅仅简单的设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起
#### 3.3.3 安全区域
1. 为了处理“不执行”的程序的安全点问题，提出了安全区域来解决问题
2. 安全区域是指在一段代码片段之中，引用关系不会发生变化，在这个区域内的任何地方进行GC都是安全的
3. 虚拟机如歌具体的进行内存回收是由虚拟机所采用的GC收集器决定的，而通常虚拟机中往往不止有一种GC收集器
### 3.4 垃圾收集器
- 如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现
- 不同的收集器应用的区域不同，到现在为止没有最好的收集器，也没有万能的收集器
#### 3.4.1 Serial收集器
1. Serail收集器是“单线程”的，他在进行垃圾收集时必须暂停其他的所有线程，直到收集结束
2. 随着收集器的发展，用户线程的停顿时间越来越段，但任然无法消除
3. Serial收集器是虚拟机运行在Client模式下默认的新生代收集器
4. 对于单个CPU坏境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集，可以获得很高的单线程收集效率
#### 3.4.2 ParNew收集器
1.ParNew收集器是Serial收集器的多线程版本
2.ParNew收集器是运行在Server模式下虚拟机中首选的新生代收集器
3.在垃圾收集器中“并发”与“并行”的概念：
- 并行：多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态
- 并发：用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行在另一个CPU上
#### 3.4.3 Parallel Scavenge 收集器
1. Parallel Scavenge收集器是一个新生代收集器，采用复制算法
2. Parallel Scavenge收集器的特点是他的关注点与其他收集器不同。其他收集器的目标是尽可能的缩短用户线程的停顿时间，而Parallel Scavenge收集器的目标是达到一个可控的吞吐量
3. 高吞吐量可以高效的利用CPU时间，尽快得完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务
4. GC停顿时间的缩短是以牺牲吞吐量和新生代空间来换取的
5. Parallel Scavenge收集器也经常被称为“吞吐量优先”收集器
#### 3.4.4 Serial Old收集器
1. Serial Old收集器是Serail收集器的老年代版本，是一个单线程收集器，使用标记-整理算法
2. Serail Old收集器主要用于Clinet模式下
3. Serail Old收集器另一种用途是作为CMS收集器的后备预案
#### 3.4.5 Parallel Old收集器
1. Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法
2. 在注重吞吐量和CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器
#### 3.4.6 CMS 收集器
1. CMS收集器是一种以获取最短的回收停顿时间为目标的收集器
2. CMS收集器基于标记-清楚算法实现，分为四个步骤：初始标记、并发标记、重新标记、并发清除
3. 步骤详解：
- 初始标记：标记一下GC Roots能直接关联到的对象，速度很快  
- 并发标记：进行GC Roots Tracing  
- 重新标记：是为了修正那些在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，在这一阶段的停顿时间会比初始标记阶段稍长一点  
4. 从总体上说，CMS收集器的内存回收过程是与用户线程一起并发执行的
5. CMS收集器的缺点：  
- CMS收集器对CPU资源非常敏感  
- CMS收集器无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败而导致另一次Full FC的产生  
- 由于CMS收集器采用了标记-清除算法，所以在回收结束时会有大量空间碎片产生，碎片过多时，在给大对象分配内存时会有很大麻烦
#### 3.4.7 G1 收集器
1. G1收集器是一款面向服务端应用的垃圾收集器
2. G1收集器具备以下特点：  
- 并行与并发  
- 分代收集
- 空间整合：从整体上来看是基于“标记-整理”算法实现的，在局部上是基于复制算法实现的  
- 可预测的停顿   
3. G1收集器将整个Java堆划分为多个大小相等的独立区域，虽然还保留有新生代和老生代的概念，但新生代和老生代不再是物理隔的了，他们是一部分Region的集合4.G1收集器可以有计划地避免在整个Java堆中进行全区域的垃圾收集：跟踪各个Region里面的垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region5.在G1收集器中，使用Remembered Set来避免全堆扫描
#### 3.4.8 理解GC日志
这里使用如下的参数来进行日志的打印：
> -XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:./gclogs

1. 对于新生代回收的一行日志，其基本内容如下：

    `2014-07-18T16:02:17.606+0800: 611.633: [GC 611.633: [DefNew: 843458K->2K(948864K), 0.0059180 secs] 2186589K->1343132K(3057292K), 0.0059490 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]`

    其含义大概如下：

    `2014-07-18T16:02:17.606+0800（当前时间戳）: 611.633（时间戳）: [GC（表示Young GC） 611.633: [DefNew（单线程Serial年轻代GC）: 843458K（年轻代垃圾回收前的大小）->2K（年轻代回收后的大小）(948864K（年轻代总大小）), 0.0059180 secs（本次回收的时间）] 2186589K（整个堆回收前的大小）->1343132K（整个堆回收后的大小）(3057292K（堆总大小）), 0.0059490 secs（回收时间）] [Times: user=0.00（用户耗时） sys=0.00（系统耗时）, real=0.00 secs（实际耗时）]`


2. 老年代回收的日志如下：
    `2014-07-18T16:19:16.794+0800: 1630.821: [GC 1630.821: [DefNew: 1005567K->111679K(1005568K), 0.9152360 secs]1631.736: [Tenured: 2573912K->1340650K(2574068K), 1.8511050 secs] 3122548K->1340650K(3579636K), [Perm : 17882K->17882K(21248K)], 2.7854350 secs] [Times: user=2.57 sys=0.22, real=2.79 secs]`
    
 
- GC日志以  [GC   或  [Full GC  开头，说明此次垃圾收集的停顿类型  而不是用来区分新生代GC还是老年代GC。
- 有过有Full 说明这次GC发生了Stop_The_World的，
- 如果是调用System.gc()方法 这里显示  [Full GC(System)  
`[Full GC 288.331: [ParNew: 261599K->261599K(261952K), 0.0000233 secs]]`
- 接下来的[DefNew [Tenured [Perm 表示 GC发生的区域 这里显示的区域与使用的GC收集器密切相关
- 例如 ：
- Serial收集器新生代为Default New Generation 显示[DefNew 
- ParNew收集器新生代为Parallel New Generation 显示 [ParNew 
- Parallel Scavenge收集器新生代为 [PSYoungGen 
- 老年代和永久同理，名称是由收集器决定的。
- 
- 3324K->152K(3712K)
- 理解为 GC前该内存区域已使用容量 -> GC后该内存区域已使用容量 (该内存区域总容量)
- 在[] 外的 3324K->152K(3712K) 表示  GC前Java堆已使用容量 ->  GC后Java堆已使用容量(Java堆总容量)
- [Times: user=0.01 sys=0.00 real=0.02 secs] 分表代表 用户态消耗的CPU时间 内核态小号的CPU事件 操作从开始到结束所经过的墙钟时间


### 3.5 内存技术与回收策略
对象的内存分配，往大方向讲，就是在堆上分配，主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配，少数情况也可能会直接分配在老年代中，具体的分配规则取决于虚拟机自己的设置
#### 3.5.1 对象优先在Eden分配
1. 大多数情况下，对象优先在新生代的Eden区分配
2. 当Eden区没有足够的空间时，虚拟机将发起一次Minor GC3.Minor GC与Full GC：
- Minor GC：新生代GC，非常频繁，回收速度快  
- Fulll GC：老年代GC，又称为Major GC，经常会伴随一次Minor GC，速度比较慢
#### 3.5.2 大对象直接进入老年代
1. 大对象是指需要大量连续的内存空间的Java对象
2. 虚拟机提供了一个参数：PretenureSizeThreshold，大于这个参数的对象将直接在老年代分配
#### 3.5.3 长期存活的对象将进入老年年代
虚拟机给每个对象定义了一个对象年龄计数器（Age），对象每经过一次Minor GC后仍然存活，且能被Survivor容纳的话，年龄就 +1 ，当年龄增加到一定程度（默认为15），就会被晋升到老年代中，这个阈值可以通过参数 MaxTenuringThreshold 来设置
#### 3.5.4 动态对象年龄判断
1. 为了更好的适应不同程序的内存状况，对象年龄不是必须到达阈值才会进入老年代
2. 当Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，或年龄大于等于该年龄的对象就可以直接进入老年代
#### 3.5.5 空间分配担保
1. 在发生Minor GC之前，虚拟机会首先检查老年代可用最大内存空间是否大于新生代对象总空间—若大于，则会进行一次安全的Minor GC
2. 若上述条件不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败，若不允许，则进行一次FULL GC
3. 若允许担保失败，则虚拟机会检查老年代最大可用的连续空间是否大于历次晋升到老年代的对象的平均大小，若大于，则进行一次冒险的Minor GC，否则进行一次FULL GC4.若担保失败，还是会进行一次FULL GC。之所以要冒险的原因是为了避免频繁的FULL GC
## 第四章 虚拟机性能监控与故障处理工具
### 4.1 概述
给一个系统定位问题的时候，知识，经验是关键基础，数据是依据，工具是运用知识处理数据源的手段。这里说的数据包括：
- 运行日志
- 异常堆栈
- GC日志
- 线程快照
- 堆转储快照
经常使用适当的虚拟机监控和分析的工具可以加快我们分析数据，定位解决问题的速度，但在学习工具前，也应当意识到工具永远都是知识技能的一层包装，
没有什么工具是“秘密武器”，不可能学会了就能包治百病。
### 4.2 JDK的命令行工具
JDK开发团队的工具都是对tools.jar类库的一层薄包装。
- jps ---  JVMProcess Status Tool 显示指定系统内所有的HotSpot的虚拟机进程
- jstat ---  JVM Statistics Monitoring Tool 用于收集HotSpot虚拟机各方面的运行数据
- jinfo ---  Configuration Info for java 显示虚拟机配置信息
- jmap --- Memory Map for java 生成虚拟机的内存快储快照（heapdump文件） 
- jhat ---  JVM Heap Dump Browser 用于分析heapdump文件 他会建立一个Http/html服务器，让用户可以在浏览器上查看分析结果
- jstack --- Stack Trace for java 显示虚拟机的线程快照
 #### 4.2.1 jps虚拟机进程状况工具
 jps -q 只输出LVMID 省略主类的名称
 jps -m 输出虚拟机进程启动时传递给住类main()函数的参数
 jps -l 输出主类的全名 如果进程执行的是jar包，输出jar路径
 jps -p 输出虚拟机进程启动时的jvm参数
 #### 4.2.2 jstat虚拟机统计信息监视工具
 #### 4.2.3 jinfo java配置信息工具
 #### 4.2.4 jmap java内存映射工具
 #### 4.2.5 jhat 虚拟机堆转储快照分析工具
 #### 4.2.6 jstack java堆栈跟踪工具
 #### 4.2.7 HSDIS JIT生成代码反汇编
 ### 4.3 JDK可视化工具
 JConsole和VisualVM
 #### 4.3.1 JConsole java 监控与管理控制台
 #### 4.3.2 VisualVM 多合一故障处理工具
 ## 第五章 调优案例分析与实战
 ## 第六章 类文件结构
 
 
  




























