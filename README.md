#  深入了解JVM
## 第一章 走进jvm
`jdk 包括 java语言，工具及工具API， JRE`
## 第二章 java内存区域与内存溢出异常
### 2.1运行时数据区域
java虚拟机在执行java程序的过程中会把他所管理的内存划分为若干个不同的数据区域。
![Java虚拟机运行时数据区](https://pic4.zhimg.com/v2-2d12cf4d44699ee760ff6874604497a3_r.jpg)
#### 2.1.1 程序计数器
JVM中的程序计数器是一块很小的内存区域，但是这块内存区域挺有意思的。主要特性有3个：
1. 存储内容：对于java普通方法（即没用native关键字修饰的方法），存储的是执行过程中当前指令的地址，而对于native方法，这里是空的（undefined），为啥呢？因为调用本地方法的时候可能已经超出了JVM虚拟机的内存地址了。
2. 线程私有的：为什么程序计数器是线程私有的？根据存储内容也好理解，假如是线程共享的，那多个线程执行的时候，都不知道自己当前线程执行的地址是哪个了，有的线程快，有的线程慢，快的执行完就进入下一步，等慢的线程执行完回来发现自己的地址都变了，岂不乱套？
3. 是JVM中唯一不会报内存溢出（OutOfMemoryError）的区域。
#### 2.1.2 java虚拟机栈
关于虚拟机栈内存溢出有2种情况：
1. 线程请求的栈深度 超过了虚拟机允许的深度，会抛出StackOverflowError，所以当我们在代码中看到这个异常时，就应该想到可能是虚拟机栈出了问题。
2. 如果虚拟机栈可以动态扩展（当前大部分JVM都可以动态扩展，不过JVM也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时，会抛出OutOfMemoryError异常。
#### 2.1.3 本地方法区
这块知识点比较简单，本地方法栈和虚拟机栈的功能类似，只不过是为JVM调用native方法时服务的，而且JVM对本地方法使用的语言（比如Java调用C语言实现的功能，就需要定义native方法来实现）、使用方式和数据结构都没有强制规定，因此不同的虚拟机可以自由实现。而且HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一。与虚拟机栈类似，本地方法栈也会抛出StackOverflowError和OutOfMemoryError。
#### 2.1.4 java堆
Java堆区是JVM内存中最胖的一块区域，因为这里存储的都是对象的实例和数组对象。这块区域是线程共享的，在JVM启动时就会创建，想想如果这么大的空间是线程私有的，那内存不得爆掉吗？按照java虚拟机规范，堆区的内容可以物理上不连续，只要逻辑上连续即可，在实现时可以是固定大小的，也可以是可扩展的，而且通常都是可扩展的，我们常用的内存参数-Xms和-Xmx就是用来调节堆大小的。java堆区按生命周期不同，分为新生代和老年代。新生代又可以细分为Eden和Survivor区，而Survivor又可以细分为Survivor1和Survivor2，这两者通常只使用其中一块，另一块用来GC时保留存活的对象。大部分的new出来的对象都是存放在Eden区，如果是大对象，比如一个很大的数组或者List对象，可以通过JVM参数-XX:PretenureSizeThreshold将超过指定大小的对象直接存入到老年代，需要注意的是，写程序时应该尽量避免朝生夕死的大对象进入老年代，因为相比年轻代的GC，老年代GC的成本更大。Eden和Survivor的默认大小比值的8:1:1，新生代默认的GC算法是复制算法。老年代的默认GC算法是标记整理法。

![](https://pic3.zhimg.com/v2-730e4db82c217037bebfe726602f9486_b.jpg)
### 2.2 HotSpot虚拟机对象探秘
#### 2.2.1 对象的创建
1. 虚拟机在遇到一条new指令时，首先会检查这个指令的参数是否能在常量池中定位到一个类的符号引用,并且检查该类是否已加载。如果没有加载，还要先执行相应的类加载过程
2. 内存分配方式有两种，选择哪种方式由Java堆是否规整决定，若规整，则采用“指针碰撞”方式，若不规整，则采用“空闲列表方式”；而是否规整又由所采用的垃圾回收机制决定
3. 解决并发环境下的分配内存有两种方式:  对分配内存空间的动作进行同步处理  把内存分配的动作按照线程划分在不同的空间中进行，即每个线程在堆中预先分配一小块内存（TLAB）
4. 内存分配完成后还要将分配的内存空间都初始化为零值，从而保证对象的实例字段在Java代码中可以不赋初始值就直接使用
5. 初始化后还要给对象进行相关各设置，诸如哈希码、GC分代年龄信息等6.上述工作结束后，从虚拟机视角来看，一个新的对象已经产生了；但从Java程序的角度来看，对象的创建才刚刚开始————进行Java代码的初始化操作
#### 2.2.2 对象的内存布局
1. 对象在内存中存储的布局可以分为三块区域：对象头、实例数据、对齐填充
2. 对象头一搬包含两部分内容：对象的运行时数据和类型指针。如果对象是数组，则还有一个部分来记录数组的长度
3. 运行时数据指哈希码、GC分代年龄等信息，被设计成一个非固定的数据结构以便在极小的空间存储尽量多的信息，会根据对象的状态复用自己的存储空间
4. 类型指针是对象指向他的类元数据的指针，虚拟机通过这个指针确定对象是哪个类的实例
5. 实例数据是对象真正存储的有效信息，即程序中的字段内容
6. 实例数据默认的分配策略是按顺序，相同宽度的字段总是分配在一起
7. 对齐填充不是必然的，仅仅起着占位符的作用
8. 对象的大小必须是8字节的整数倍，对象头部分正好是8字节的倍数
#### 2.2.3 对象的访问定位
1. Java程序通过栈上的reference数据来操作堆上的具体对象
2. 对象的访问形式取决于虚拟机，目前主流的有两种方式：使用句柄  和  直接指针
3. 使用句柄是间接访问，优点是reference中存储的是稳定的句柄地址，对象移动时只会改变句柄中的实例数据指针
4. 使用直接指针是直接访问，优点就是速度快
### 2.3 OutOfMemoryError异常
#### 2.3.1 java栈溢出
Java堆用于存储对象实例，只要不断的创建对象，且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量达到最大堆的容量限制之后就会产生内存溢出的异常
#### 2.3.2 虚拟机和本地方法栈的溢出
1. HotSpot虚拟机中并不区分虚拟机栈和本地方法栈
2. 关于虚拟机栈和本地方法栈，Java虚拟机规范中描述了量中异常：
- 如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常
- 如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常
3. 在单个线程下，无论是由于栈太小还是虚拟机栈容量太小，当内存无法分配时，虚拟机抛出的都是StackOverflowError异常
#### 2.3.3 方法区和运行时常量池溢出
1. 在JDK 1.6中 intern() 方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用
2. 在JDK 1.7中 intern() 方法不会再复制实例，只是在常量池中记录首次出现的实例引用
3. StringBuilder 创建的字符串实例在Java堆上
## 第三章 垃圾收集器与内存分配策略
### 3.1 对象已死吗？
#### 3.1.1 引用计数法
主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是他很难解决对象之间互相引用的问题。
#### 3.1.2 可达性分析算法
1. 主流的商用程序语言的主流实现中都是用可达性分析来判断对象是否存活的
2. 从一个起始对象GC Roots开始向下搜索，搜索所走过的路径称为引用链，档一个对象到GC Roots没有任何引用链时，即从GC Roots到这个对象不可达，则证明此对象是不可用的
3. 在Java语言中，可作为GC Roots的对象包括一下四种：
 - 虚拟机栈（栈帧中的本地变量表）中引用的对象
 - 方法区中类静态属性引用的对象
 - 方法区中常亮引用的对象
 - 本地方法栈中JNI(即一般说的Native方法)引用的对象
#### 3.1.3 再谈引用
Java的引用可以分为强引用、软引用、弱引用、虚引用：
- 强引用：是指在程序代码中直接存在的引用，譬如引用new操作符创建的对象。只要强引用还存在，垃圾收集器就永远不会回收掉被引用的对象
- 软引用：还有用但是并非必需的引用，早系统将要发生内存溢出异常之前会把这些对象列进回收范围中进行二次回收，若还是没有足够的内存，才会抛出内存溢出异常
- 弱引用：非必需的对象，只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论内存是否够用都将回收这些对象
- 虚引用：一个对象是否有虚引用的存在完全不会对他的生存时间构成影响，也无法通过虚引用来取得一个对象实例
#### 3.1.4 生存还是死亡
1. 要真正宣告一个对象死亡，需要两个标记过程：
- 若对象在进行可达性分析后发现没有与GC Roots相连接的引用链，会被第一次标记并筛选。筛选的条件是此对象是否有必要执行finalize()方法
- finalize()方法是对象逃脱死亡的最后一次机会，稍后GC会对对象进行第二次标记
2. 当对象没有覆盖finalize()方法或者finalize()方法已经由虚拟机调用过，都视为finalize()没有必要执行
#### 3.1.5 回收方法区
1. 永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类
2. 类需要同时满足一下三个条件才能算是“无用的类”：
- 该类所有的实例都已经被回收，即Java堆中不再有该类的实例
- 加载该类的ClassLoader已经被回收
- 该类对应的java.lang.Class对象没有在任何地方被调用，无法在任何地方通过反射访问该类的方法
### 3.2 垃圾收集算法
#### 3.2.1 标记-清除算法


















